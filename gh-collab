#!/usr/bin/env bash
# ==============================================================================
# gh-collab - A GitHub CLI extension to manage repository collaborators
# ==============================================================================
# 
# WHAT THIS SCRIPT DOES:
#   Adds a GitHub user as a collaborator to a repository using the GitHub API.
#   Think of it like: "yo, let this person access my private repo"
#
# USAGE:
#   gh collab add <username>                    # add to current repo
#   gh collab add <username> -R owner/repo      # add to specific repo
#
# PYTHON EQUIVALENT (if this were Python):
#   import subprocess
#   subprocess.run(["gh", "api", f"repos/{owner}/{repo}/collaborators/{user}", "-X", "PUT"])
#
# AUTHOR: nalediym
# REPO: https://github.com/nalediym/gh-collab
# ==============================================================================

# ------------------------------------------------------------------------------
# Bash settings (like Python's "strict mode")
# ------------------------------------------------------------------------------
# In Python, errors raise exceptions by default. Bash doesn't do that unless
# we tell it to. These settings make bash behave more like Python:

set -e          # Exit immediately if any command fails (like raising an exception)
                # Without this, bash would just... keep going. Chaos.
                # Python equivalent: every line is implicitly in a try block that re-raises

set -o pipefail # If a piped command fails, the whole pipe fails
                # Example: "cmd1 | cmd2" fails if cmd1 fails, not just cmd2
                # Without this: "false | echo hi" would succeed (!)

# ------------------------------------------------------------------------------
# COLORS (for pretty output)
# ------------------------------------------------------------------------------
# These are ANSI escape codes. When you print them, the terminal changes colors.
# We check if stdout is a terminal (tty) - if not (like when piping), no colors.
#
# Python equivalent:
#   if sys.stdout.isatty():
#       RED = "\033[0;31m"
#   else:
#       RED = ""

if [[ -t 1 ]]; then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[0;33m'
    BLUE='\033[0;34m'
    NC='\033[0m'  # NC = "No Color" - resets the color
else
    RED=''
    GREEN=''
    YELLOW=''
    BLUE=''
    NC=''
fi

# ------------------------------------------------------------------------------
# CONFIGURATION / DEFAULTS
# ------------------------------------------------------------------------------
# The permission level for new collaborators
# Options: pull (read), push (write), admin, maintain, triage
DEFAULT_PERMISSION="push"

# TODO: Add a config file option (~/.config/gh-collab/config) for user defaults

# ------------------------------------------------------------------------------
# HELPER FUNCTIONS
# ------------------------------------------------------------------------------

# Print usage/help information
# In Python, this would be like argparse's auto-generated help, but we write it manually
# The 'cat << EOF' syntax is called a "heredoc" - it prints everything until 'EOF'
# Think of it like a multi-line f-string in Python
show_help() {
    cat << EOF
${BLUE}gh-collab${NC} - Manage repository collaborators from the command line

${YELLOW}USAGE:${NC}
    gh collab add <user> [user2 ...]         Add collaborator(s) to current repo
    gh collab add <user> -R owner/repo       Add collaborator(s) to specific repo
    gh collab remove <user> [user2 ...]      Remove collaborator(s)
    gh collab list                           List all collaborators
    gh collab check <user> [user2 ...]       Check if user(s) are collaborators

${YELLOW}OPTIONS:${NC}
    -R, --repo <owner/repo>       Target repository (default: current repo)
    -p, --permission <level>      Permission level (default: push)
    -h, --help                    Show this help message

${YELLOW}PERMISSION LEVELS:${NC}
    pull      Read-only access
    push      Read and write access (default)
    admin     Full admin access
    maintain  Manage repo without admin access
    triage    Manage issues and PRs without write access

${YELLOW}EXAMPLES:${NC}
    gh collab add octocat                        # Add with default (push) permission
    gh collab add octocat --permission admin     # Add with admin permission
    gh collab add octocat -R myorg/myrepo        # Add to specific repo
    gh collab add alice bob charlie              # Batch add multiple users
    gh collab remove octocat                     # Remove collaborator
    gh collab remove alice bob                   # Batch remove multiple users
    gh collab list                               # List all collaborators
    gh collab list -R myorg/myrepo               # List collaborators for specific repo
    gh collab check octocat                      # Check if user is a collaborator
    gh collab check alice bob                    # Check multiple users
EOF
}

# Print an error message in red and exit with code 1
# Similar to Python's: raise SystemExit(f"Error: {message}")
#
# The >&2 redirects output to stderr (standard error) instead of stdout
# Python equivalent: print(f"Error: {message}", file=sys.stderr)
die() {
    echo -e "${RED}Error:${NC} $1" >&2
    exit 1
}

# Print an info message in blue
# Just for pretty output, nothing fancy
info() {
    echo -e "${BLUE}=>${NC} $1"
}

# Print a success message in green
success() {
    echo -e "${GREEN}=>${NC} $1"
}

# Print a warning message in yellow
warn() {
    echo -e "${YELLOW}Warning:${NC} $1"
}

# Detect the current repository from git remote
# Returns format: "owner/repo"
#
# This uses the gh CLI to ask "what repo am I currently in?"
# It's smart - it looks at your git remotes and figures it out
#
# The 2>/dev/null suppresses error messages (like stderr going to /dev/null)
# Python equivalent: 
#   try:
#       result = subprocess.run([...], capture_output=True)
#       return result.stdout
#   except:
#       return None
get_current_repo() {
    gh repo view --json nameWithOwner --jq '.nameWithOwner' 2>/dev/null
}

# ------------------------------------------------------------------------------
# ARGUMENT PARSING
# ------------------------------------------------------------------------------
# In Python you'd use argparse or click. In bash, we manually loop through args.
#
# $@ is like sys.argv[1:] - all arguments passed to the script
# $# is like len(sys.argv[1:]) - the count of arguments
# $1, $2, etc. are like sys.argv[1], sys.argv[2], etc.
#
# 'shift' removes the first argument, so $2 becomes $1, $3 becomes $2, etc.
# It's like: args.pop(0) in Python

SUBCOMMAND=""       # Will be "add", "remove", "list", "check"
USERNAMES=()        # Array of GitHub usernames to add/remove/check
REPO=""             # The target repository (owner/repo format)
PERMISSION=""       # Permission level (pull/push/admin/maintain/triage)

# Loop through all arguments
# [[ $# -gt 0 ]] means "while argument count > 0"
# Python equivalent: while len(args) > 0:
while [[ $# -gt 0 ]]; do
    case "$1" in
        # -----------------
        # Help flags
        # -----------------
        -h|--help)
            show_help
            exit 0
            ;;
        
        # -----------------
        # Repository flag (takes next argument as value)
        # -----------------
        # The -R flag is followed by the repo name, so we need $2
        -R|--repo)
            # Check that there IS a next argument
            if [[ -z "$2" || "$2" == -* ]]; then
                die "-R requires a repository argument (e.g., -R owner/repo)"
            fi
            REPO="$2"       # $2 is the next argument after -R
            shift 2         # Remove TWO args: -R and its value
            ;;
        
        # -----------------
        # Permission flag (takes next argument as value)
        # -----------------
        -p|--permission)
            if [[ -z "$2" || "$2" == -* ]]; then
                die "--permission requires an argument (pull/push/admin/maintain/triage)"
            fi
            # Validate permission value
            if [[ ! "$2" =~ ^(pull|push|admin|maintain|triage)$ ]]; then
                die "Invalid permission: '$2'. Must be one of: pull, push, admin, maintain, triage"
            fi
            PERMISSION="$2"
            shift 2
            ;;
        
        # -----------------
        # Subcommands
        # -----------------
        add)
            SUBCOMMAND="add"
            shift           # Remove this argument, move to next
            ;;
        
        remove)
            SUBCOMMAND="remove"
            shift
            ;;
        
        list)
            SUBCOMMAND="list"
            shift
            ;;
        
        check)
            SUBCOMMAND="check"
            shift
            ;;
        
        # -----------------
        # Unknown flags (start with -)
        # -----------------
        -*)
            die "Unknown option: $1 (try --help)"
            ;;
        
        # -----------------
        # Positional arguments (don't start with -)
        # -----------------
        *)
            # If we already have a subcommand, this is probably a username
            if [[ -n "$SUBCOMMAND" ]]; then
                USERNAMES+=("$1")
            else
                # No subcommand yet - maybe they forgot?
                die "Unknown command: $1. Did you mean 'gh collab add $1'?"
            fi
            shift
            ;;
    esac
done

# ------------------------------------------------------------------------------
# VALIDATION
# ------------------------------------------------------------------------------
# Make sure we have everything we need before making API calls
# This is like having a bunch of "if not x: raise ValueError(...)" in Python

# Must have a subcommand
if [[ -z "$SUBCOMMAND" ]]; then
    # No command given - show help
    show_help
    exit 0
fi

# For "add", "remove", "check" commands, we need at least one username
if [[ "$SUBCOMMAND" =~ ^(add|remove|check)$ && ${#USERNAMES[@]} -eq 0 ]]; then
    die "Username required. Usage: gh collab $SUBCOMMAND <username> [username2 ...]"
fi

# If no repo specified, try to detect from current directory
if [[ -z "$REPO" ]]; then
    info "No repo specified, detecting from current directory..."
    REPO=$(get_current_repo) || die "Not in a git repo. Use -R owner/repo to specify."
    info "Detected repo: ${BLUE}${REPO}${NC}"
fi

# Validate repo format (should be owner/repo)
# The regex ^[^/]+/[^/]+$ means:
#   ^ = start of string
#   [^/]+ = one or more characters that are NOT a slash
#   / = a literal slash
#   [^/]+ = one or more characters that are NOT a slash
#   $ = end of string
# So it matches "owner/repo" but not "owner" or "owner/repo/extra"
if [[ ! "$REPO" =~ ^[^/]+/[^/]+$ ]]; then
    die "Invalid repo format: '$REPO'. Expected: owner/repo"
fi

# ------------------------------------------------------------------------------
# MAIN LOGIC
# ------------------------------------------------------------------------------
# This is where the actual work happens!

# Handle the "add" subcommand
if [[ "$SUBCOMMAND" == "add" ]]; then
    # Use specified permission or fall back to default
    PERM="${PERMISSION:-$DEFAULT_PERMISSION}"
    FAILED=0
    
    for USERNAME in "${USERNAMES[@]}"; do
        info "Adding '${YELLOW}${USERNAME}${NC}' as collaborator to '${BLUE}${REPO}${NC}' with ${GREEN}${PERM}${NC} permission..."
        
        # Make the API call!
        # GitHub API endpoint: PUT /repos/{owner}/{repo}/collaborators/{username}
        # Docs: https://docs.github.com/en/rest/collaborators/collaborators#add-a-repository-collaborator
        # 
        # --method PUT = HTTP PUT request (creates or updates)
        # --field permission=X = sends JSON body {"permission": "X"}
        # --silent = don't print the response body (we just care if it worked)
        #
        # Note: The API returns different status codes:
        #   - 201: Invitation created (new collaborator)
        #   - 204: User is already a collaborator (permission updated)
        #   - 422: Validation failed (user might not exist)
        
        # Capture HTTP status code to differentiate responses
        HTTP_STATUS=$(gh api "repos/${REPO}/collaborators/${USERNAME}" \
            --method PUT \
            --field permission="$PERM" \
            --silent \
            --include 2>&1 | grep -i "^HTTP/" | tail -1 | awk '{print $2}') || true
        
        if [[ "$HTTP_STATUS" == "201" ]]; then
            success "Invitation sent to '${YELLOW}${USERNAME}${NC}'"
        elif [[ "$HTTP_STATUS" == "204" ]]; then
            success "'${YELLOW}${USERNAME}${NC}' is already a collaborator (permission updated to ${GREEN}${PERM}${NC})"
        elif [[ -n "$HTTP_STATUS" && "$HTTP_STATUS" =~ ^2 ]]; then
            # Some other 2xx success
            success "Collaborator '${YELLOW}${USERNAME}${NC}' added"
        else
            # The gh api command failed
            warn "Failed to add '${YELLOW}${USERNAME}${NC}' - user may not exist or you lack permission"
            FAILED=$((FAILED + 1))
        fi
    done
    
    # Show summary for batch operations
    if [[ ${#USERNAMES[@]} -gt 1 ]]; then
        echo ""
        SUCCEEDED=$((${#USERNAMES[@]} - FAILED))
        if [[ $FAILED -eq 0 ]]; then
            success "All ${SUCCEEDED} collaborators added successfully!"
        else
            warn "${SUCCEEDED} succeeded, ${FAILED} failed"
        fi
    fi
    
    # Show invitation link
    if [[ $FAILED -lt ${#USERNAMES[@]} ]]; then
        echo ""
        echo "Invitees will receive an email and need to accept it."
        echo "You can also share this link: ${BLUE}https://github.com/${REPO}/invitations${NC}"
    fi
    
    # Exit with error if any failed
    [[ $FAILED -gt 0 ]] && exit 1
fi

# ------------------------------------------------------------------------------
# FUTURE SUBCOMMANDS (not implemented yet)
# ------------------------------------------------------------------------------
# These are stubbed out for future development. Remove the comments and
# implement them when you're ready!

# Handle the "remove" subcommand
if [[ "$SUBCOMMAND" == "remove" ]]; then
    FAILED=0
    
    for USERNAME in "${USERNAMES[@]}"; do
        info "Removing '${YELLOW}${USERNAME}${NC}' from '${BLUE}${REPO}${NC}'..."
        if gh api "repos/${REPO}/collaborators/${USERNAME}" --method DELETE --silent 2>/dev/null; then
            success "Removed '${YELLOW}${USERNAME}${NC}'"
        else
            warn "Failed to remove '${YELLOW}${USERNAME}${NC}' - may not be a collaborator"
            FAILED=$((FAILED + 1))
        fi
    done
    
    # Show summary for batch operations
    if [[ ${#USERNAMES[@]} -gt 1 ]]; then
        echo ""
        SUCCEEDED=$((${#USERNAMES[@]} - FAILED))
        if [[ $FAILED -eq 0 ]]; then
            success "All ${SUCCEEDED} collaborators removed successfully!"
        else
            warn "${SUCCEEDED} succeeded, ${FAILED} failed"
        fi
    fi
    
    [[ $FAILED -gt 0 ]] && exit 1
fi

# Handle the "list" subcommand
if [[ "$SUBCOMMAND" == "list" ]]; then
    info "Collaborators for '${BLUE}${REPO}${NC}':"
    echo ""
    # The --jq flag uses jq syntax to format JSON output
    # .[].login extracts the 'login' field from each item in the array
    if ! gh api "repos/${REPO}/collaborators" --jq '.[] | "  \(.login) (\(.role_name))"'; then
        die "Failed to list collaborators. Check repo access."
    fi
fi

# Handle the "check" subcommand
if [[ "$SUBCOMMAND" == "check" ]]; then
    NOT_COLLABORATORS=0
    
    for USERNAME in "${USERNAMES[@]}"; do
        # This endpoint returns 204 if user is collaborator, 404 if not
        if gh api "repos/${REPO}/collaborators/${USERNAME}" --silent 2>/dev/null; then
            success "'${YELLOW}${USERNAME}${NC}' is a collaborator on '${BLUE}${REPO}${NC}'"
        else
            warn "'${YELLOW}${USERNAME}${NC}' is NOT a collaborator on '${BLUE}${REPO}${NC}'"
            NOT_COLLABORATORS=$((NOT_COLLABORATORS + 1))
        fi
    done
    
    [[ $NOT_COLLABORATORS -gt 0 ]] && exit 1
fi
